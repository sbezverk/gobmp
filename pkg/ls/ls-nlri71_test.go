package ls

import (
	"testing"

	"github.com/sbezverk/gobmp/pkg/base"
	"github.com/sbezverk/gobmp/pkg/srv6"
	"github.com/sbezverk/gobmp/pkg/te"
)

func TestLSNLRI71(t *testing.T) {
	tests := []struct {
		name     string
		input    []byte
		nlri     NLRI71
		fail     bool
		elements []Element
	}{
		// {
		// 	name:  "ls node update",
		// 	input: []byte{0x00, 0x01, 0x00, 0x27, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		// 	fail:  false,
		// 	elements: []Element{
		// 		{
		// 			Type: 1,
		// 			LS:   &base.NodeNLRI{},
		// 		},
		// 	},
		// },
		// {
		// 	name:  "ls link update",
		// 	input: []byte{0x00, 0x02, 0x00, 0x73, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x01, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0xFD, 0xE8, 0x02, 0x01, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x05, 0x00, 0x10, 0xFC, 0x00, 0xDD, 0xDD, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x01, 0x06, 0x00, 0x10, 0xFC, 0x00, 0xDD, 0xDD, 0x00, 0x03, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x01, 0x07, 0x00, 0x02, 0x00, 0x02},
		// 	fail:  false,
		// 	elements: []Element{
		// 		{
		// 			Type: 2,
		// 			LS:   &base.LinkNLRI{},
		// 		},
		// 	},
		// },
		{
			name:  "panic #1",
			input: []byte{0x00, 0x04, 0x00, 0x3c, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5F, 0x50, 0x01, 0x00, 0x00, 0x1A, 0x02, 0x00, 0x00, 0x04, 0x00, 0x00, 0x5F, 0x50, 0x02, 0x01, 0x00, 0x04, 0xD3, 0x88, 0xBF, 0xFF, 0x02, 0x03, 0x00, 0x06, 0x21, 0x11, 0x36, 0x19, 0x12, 0x36, 0x01, 0x09, 0x00, 0x11, 0x7F, 0x24, 0x09, 0x80, 0x1E, 0x00, 0xF0, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xCA},
			fail:  false,
			elements: []Element{
				{
					Type: 4,
					LS:   &base.PrefixNLRI{},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n, err := UnmarshalLSNLRI71(tt.input)
			if err != nil && !tt.fail {
				t.Fatalf("test should succeed but failed with error: %+v", err)
			}
			if err == nil && tt.fail {
				t.Fatalf("test should fail but succeeded")
			}
			if err != nil {
				return
			}
			for i, e := range n.NLRI {
				if tt.elements[i].Type != e.Type {
					t.Fatalf("computed %d and expected %d nlri types do not match", e.Type, tt.elements[i].Type)
				}
				switch tt.elements[i].Type {
				case 1:
					n, ok := e.LS.(*base.NodeNLRI)
					if !ok {
						t.Fatalf("Unrecognzed NodeNLRI object")
					}
					t.Logf("Node: %+v", n)
					t.Logf("Node Descriptor: %+v", n.LocalNode)
				case 2:
					l, ok := e.LS.(*base.LinkNLRI)
					if !ok {
						t.Fatalf("Unrecognzed LinkNLRI object")
					}
					t.Logf("Link: %+v", l)
					t.Logf("Local Node Descriptor: %+v", l.LocalNode)
					t.Logf("Remote Node Descriptor: %+v", l.RemoteNode)
				case 3:
					fallthrough
				case 4:
					p, ok := e.LS.(*base.PrefixNLRI)
					if !ok {
						t.Fatalf("Unrecognzed PrefixNLRI object")
					}
					t.Logf("Prefix NLRI: %+v", p)
					t.Logf("Local Node Descriptor: %+v", p.LocalNode)
					t.Logf("Prefix Descriptor: %+v", p.Prefix)
				case 5:
					t.Logf("NLRI element: %+v", e.LS.(*te.NLRI))
				case 6:
					t.Logf("NLRI element: %+v", e.LS.(*srv6.SIDNLRI))
				default:
					t.Fatalf("non supported NLRI type: %d", tt.elements[i].Type)
				}

			}
		})
	}
}
